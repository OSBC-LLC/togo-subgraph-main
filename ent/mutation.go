// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/OSBC-LLC/togo-subgraph-main/ent/breed"
	"github.com/OSBC-LLC/togo-subgraph-main/ent/dog"
	"github.com/OSBC-LLC/togo-subgraph-main/ent/dogprofilebreed"
	"github.com/OSBC-LLC/togo-subgraph-main/ent/dogprofileowner"
	"github.com/OSBC-LLC/togo-subgraph-main/ent/image"
	"github.com/OSBC-LLC/togo-subgraph-main/ent/predicate"
	"github.com/OSBC-LLC/togo-subgraph-main/ent/profile"
	"github.com/OSBC-LLC/togo-subgraph-main/ent/user"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBreed           = "Breed"
	TypeDog             = "Dog"
	TypeDogProfileBreed = "DogProfileBreed"
	TypeDogProfileOwner = "DogProfileOwner"
	TypeImage           = "Image"
	TypeProfile         = "Profile"
	TypeUser            = "User"
)

// BreedMutation represents an operation that mutates the Breed nodes in the graph.
type BreedMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Breed, error)
	predicates    []predicate.Breed
}

var _ ent.Mutation = (*BreedMutation)(nil)

// breedOption allows management of the mutation configuration using functional options.
type breedOption func(*BreedMutation)

// newBreedMutation creates new mutation for the Breed entity.
func newBreedMutation(c config, op Op, opts ...breedOption) *BreedMutation {
	m := &BreedMutation{
		config:        c,
		op:            op,
		typ:           TypeBreed,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBreedID sets the ID field of the mutation.
func withBreedID(id uuid.UUID) breedOption {
	return func(m *BreedMutation) {
		var (
			err   error
			once  sync.Once
			value *Breed
		)
		m.oldValue = func(ctx context.Context) (*Breed, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Breed.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBreed sets the old Breed of the mutation.
func withBreed(node *Breed) breedOption {
	return func(m *BreedMutation) {
		m.oldValue = func(context.Context) (*Breed, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BreedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BreedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Breed entities.
func (m *BreedMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BreedMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BreedMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Breed.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BreedMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BreedMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Breed entity.
// If the Breed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BreedMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BreedMutation) ResetName() {
	m.name = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BreedMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BreedMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Breed entity.
// If the Breed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BreedMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BreedMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BreedMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BreedMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Breed entity.
// If the Breed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BreedMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BreedMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the BreedMutation builder.
func (m *BreedMutation) Where(ps ...predicate.Breed) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BreedMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Breed).
func (m *BreedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BreedMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, breed.FieldName)
	}
	if m.updated_at != nil {
		fields = append(fields, breed.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, breed.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BreedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case breed.FieldName:
		return m.Name()
	case breed.FieldUpdatedAt:
		return m.UpdatedAt()
	case breed.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BreedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case breed.FieldName:
		return m.OldName(ctx)
	case breed.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case breed.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Breed field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BreedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case breed.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case breed.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case breed.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Breed field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BreedMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BreedMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BreedMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Breed numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BreedMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BreedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BreedMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Breed nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BreedMutation) ResetField(name string) error {
	switch name {
	case breed.FieldName:
		m.ResetName()
		return nil
	case breed.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case breed.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Breed field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BreedMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BreedMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BreedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BreedMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BreedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BreedMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BreedMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Breed unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BreedMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Breed edge %s", name)
}

// DogMutation represents an operation that mutates the Dog nodes in the graph.
type DogMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	full_name            *string
	age                  *int
	addage               *int
	weight_lbs           *float64
	addweight_lbs        *float64
	weight_kgs           *float64
	addweight_kgs        *float64
	size                 *string
	birthday             *time.Time
	updated_at           *time.Time
	created_at           *time.Time
	clearedFields        map[string]struct{}
	image                *uuid.UUID
	clearedimage         bool
	ownerProfiles        map[uuid.UUID]struct{}
	removedownerProfiles map[uuid.UUID]struct{}
	clearedownerProfiles bool
	done                 bool
	oldValue             func(context.Context) (*Dog, error)
	predicates           []predicate.Dog
}

var _ ent.Mutation = (*DogMutation)(nil)

// dogOption allows management of the mutation configuration using functional options.
type dogOption func(*DogMutation)

// newDogMutation creates new mutation for the Dog entity.
func newDogMutation(c config, op Op, opts ...dogOption) *DogMutation {
	m := &DogMutation{
		config:        c,
		op:            op,
		typ:           TypeDog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDogID sets the ID field of the mutation.
func withDogID(id uuid.UUID) dogOption {
	return func(m *DogMutation) {
		var (
			err   error
			once  sync.Once
			value *Dog
		)
		m.oldValue = func(ctx context.Context) (*Dog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDog sets the old Dog of the mutation.
func withDog(node *Dog) dogOption {
	return func(m *DogMutation) {
		m.oldValue = func(context.Context) (*Dog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dog entities.
func (m *DogMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DogMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DogMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFullName sets the "full_name" field.
func (m *DogMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *DogMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the Dog entity.
// If the Dog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *DogMutation) ResetFullName() {
	m.full_name = nil
}

// SetAge sets the "age" field.
func (m *DogMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *DogMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Dog entity.
// If the Dog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *DogMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *DogMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *DogMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetWeightLbs sets the "weight_lbs" field.
func (m *DogMutation) SetWeightLbs(f float64) {
	m.weight_lbs = &f
	m.addweight_lbs = nil
}

// WeightLbs returns the value of the "weight_lbs" field in the mutation.
func (m *DogMutation) WeightLbs() (r float64, exists bool) {
	v := m.weight_lbs
	if v == nil {
		return
	}
	return *v, true
}

// OldWeightLbs returns the old "weight_lbs" field's value of the Dog entity.
// If the Dog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogMutation) OldWeightLbs(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeightLbs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeightLbs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeightLbs: %w", err)
	}
	return oldValue.WeightLbs, nil
}

// AddWeightLbs adds f to the "weight_lbs" field.
func (m *DogMutation) AddWeightLbs(f float64) {
	if m.addweight_lbs != nil {
		*m.addweight_lbs += f
	} else {
		m.addweight_lbs = &f
	}
}

// AddedWeightLbs returns the value that was added to the "weight_lbs" field in this mutation.
func (m *DogMutation) AddedWeightLbs() (r float64, exists bool) {
	v := m.addweight_lbs
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeightLbs resets all changes to the "weight_lbs" field.
func (m *DogMutation) ResetWeightLbs() {
	m.weight_lbs = nil
	m.addweight_lbs = nil
}

// SetWeightKgs sets the "weight_kgs" field.
func (m *DogMutation) SetWeightKgs(f float64) {
	m.weight_kgs = &f
	m.addweight_kgs = nil
}

// WeightKgs returns the value of the "weight_kgs" field in the mutation.
func (m *DogMutation) WeightKgs() (r float64, exists bool) {
	v := m.weight_kgs
	if v == nil {
		return
	}
	return *v, true
}

// OldWeightKgs returns the old "weight_kgs" field's value of the Dog entity.
// If the Dog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogMutation) OldWeightKgs(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeightKgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeightKgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeightKgs: %w", err)
	}
	return oldValue.WeightKgs, nil
}

// AddWeightKgs adds f to the "weight_kgs" field.
func (m *DogMutation) AddWeightKgs(f float64) {
	if m.addweight_kgs != nil {
		*m.addweight_kgs += f
	} else {
		m.addweight_kgs = &f
	}
}

// AddedWeightKgs returns the value that was added to the "weight_kgs" field in this mutation.
func (m *DogMutation) AddedWeightKgs() (r float64, exists bool) {
	v := m.addweight_kgs
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeightKgs resets all changes to the "weight_kgs" field.
func (m *DogMutation) ResetWeightKgs() {
	m.weight_kgs = nil
	m.addweight_kgs = nil
}

// SetSize sets the "size" field.
func (m *DogMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *DogMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Dog entity.
// If the Dog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ResetSize resets all changes to the "size" field.
func (m *DogMutation) ResetSize() {
	m.size = nil
}

// SetBirthday sets the "birthday" field.
func (m *DogMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *DogMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the Dog entity.
// If the Dog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *DogMutation) ResetBirthday() {
	m.birthday = nil
}

// SetDogImgID sets the "dog_img_id" field.
func (m *DogMutation) SetDogImgID(u uuid.UUID) {
	m.image = &u
}

// DogImgID returns the value of the "dog_img_id" field in the mutation.
func (m *DogMutation) DogImgID() (r uuid.UUID, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldDogImgID returns the old "dog_img_id" field's value of the Dog entity.
// If the Dog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogMutation) OldDogImgID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDogImgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDogImgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDogImgID: %w", err)
	}
	return oldValue.DogImgID, nil
}

// ResetDogImgID resets all changes to the "dog_img_id" field.
func (m *DogMutation) ResetDogImgID() {
	m.image = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Dog entity.
// If the Dog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Dog entity.
// If the Dog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetImageID sets the "image" edge to the Image entity by id.
func (m *DogMutation) SetImageID(id uuid.UUID) {
	m.image = &id
}

// ClearImage clears the "image" edge to the Image entity.
func (m *DogMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *DogMutation) ImageCleared() bool {
	return m.clearedimage
}

// ImageID returns the "image" edge ID in the mutation.
func (m *DogMutation) ImageID() (id uuid.UUID, exists bool) {
	if m.image != nil {
		return *m.image, true
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImageID instead. It exists only for internal usage by the builders.
func (m *DogMutation) ImageIDs() (ids []uuid.UUID) {
	if id := m.image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *DogMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
}

// AddOwnerProfileIDs adds the "ownerProfiles" edge to the DogProfileOwner entity by ids.
func (m *DogMutation) AddOwnerProfileIDs(ids ...uuid.UUID) {
	if m.ownerProfiles == nil {
		m.ownerProfiles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ownerProfiles[ids[i]] = struct{}{}
	}
}

// ClearOwnerProfiles clears the "ownerProfiles" edge to the DogProfileOwner entity.
func (m *DogMutation) ClearOwnerProfiles() {
	m.clearedownerProfiles = true
}

// OwnerProfilesCleared reports if the "ownerProfiles" edge to the DogProfileOwner entity was cleared.
func (m *DogMutation) OwnerProfilesCleared() bool {
	return m.clearedownerProfiles
}

// RemoveOwnerProfileIDs removes the "ownerProfiles" edge to the DogProfileOwner entity by IDs.
func (m *DogMutation) RemoveOwnerProfileIDs(ids ...uuid.UUID) {
	if m.removedownerProfiles == nil {
		m.removedownerProfiles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ownerProfiles, ids[i])
		m.removedownerProfiles[ids[i]] = struct{}{}
	}
}

// RemovedOwnerProfiles returns the removed IDs of the "ownerProfiles" edge to the DogProfileOwner entity.
func (m *DogMutation) RemovedOwnerProfilesIDs() (ids []uuid.UUID) {
	for id := range m.removedownerProfiles {
		ids = append(ids, id)
	}
	return
}

// OwnerProfilesIDs returns the "ownerProfiles" edge IDs in the mutation.
func (m *DogMutation) OwnerProfilesIDs() (ids []uuid.UUID) {
	for id := range m.ownerProfiles {
		ids = append(ids, id)
	}
	return
}

// ResetOwnerProfiles resets all changes to the "ownerProfiles" edge.
func (m *DogMutation) ResetOwnerProfiles() {
	m.ownerProfiles = nil
	m.clearedownerProfiles = false
	m.removedownerProfiles = nil
}

// Where appends a list predicates to the DogMutation builder.
func (m *DogMutation) Where(ps ...predicate.Dog) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Dog).
func (m *DogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DogMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.full_name != nil {
		fields = append(fields, dog.FieldFullName)
	}
	if m.age != nil {
		fields = append(fields, dog.FieldAge)
	}
	if m.weight_lbs != nil {
		fields = append(fields, dog.FieldWeightLbs)
	}
	if m.weight_kgs != nil {
		fields = append(fields, dog.FieldWeightKgs)
	}
	if m.size != nil {
		fields = append(fields, dog.FieldSize)
	}
	if m.birthday != nil {
		fields = append(fields, dog.FieldBirthday)
	}
	if m.image != nil {
		fields = append(fields, dog.FieldDogImgID)
	}
	if m.updated_at != nil {
		fields = append(fields, dog.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, dog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dog.FieldFullName:
		return m.FullName()
	case dog.FieldAge:
		return m.Age()
	case dog.FieldWeightLbs:
		return m.WeightLbs()
	case dog.FieldWeightKgs:
		return m.WeightKgs()
	case dog.FieldSize:
		return m.Size()
	case dog.FieldBirthday:
		return m.Birthday()
	case dog.FieldDogImgID:
		return m.DogImgID()
	case dog.FieldUpdatedAt:
		return m.UpdatedAt()
	case dog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dog.FieldFullName:
		return m.OldFullName(ctx)
	case dog.FieldAge:
		return m.OldAge(ctx)
	case dog.FieldWeightLbs:
		return m.OldWeightLbs(ctx)
	case dog.FieldWeightKgs:
		return m.OldWeightKgs(ctx)
	case dog.FieldSize:
		return m.OldSize(ctx)
	case dog.FieldBirthday:
		return m.OldBirthday(ctx)
	case dog.FieldDogImgID:
		return m.OldDogImgID(ctx)
	case dog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Dog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dog.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case dog.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case dog.FieldWeightLbs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeightLbs(v)
		return nil
	case dog.FieldWeightKgs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeightKgs(v)
		return nil
	case dog.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case dog.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case dog.FieldDogImgID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDogImgID(v)
		return nil
	case dog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Dog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DogMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, dog.FieldAge)
	}
	if m.addweight_lbs != nil {
		fields = append(fields, dog.FieldWeightLbs)
	}
	if m.addweight_kgs != nil {
		fields = append(fields, dog.FieldWeightKgs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dog.FieldAge:
		return m.AddedAge()
	case dog.FieldWeightLbs:
		return m.AddedWeightLbs()
	case dog.FieldWeightKgs:
		return m.AddedWeightKgs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dog.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case dog.FieldWeightLbs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeightLbs(v)
		return nil
	case dog.FieldWeightKgs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeightKgs(v)
		return nil
	}
	return fmt.Errorf("unknown Dog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Dog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DogMutation) ResetField(name string) error {
	switch name {
	case dog.FieldFullName:
		m.ResetFullName()
		return nil
	case dog.FieldAge:
		m.ResetAge()
		return nil
	case dog.FieldWeightLbs:
		m.ResetWeightLbs()
		return nil
	case dog.FieldWeightKgs:
		m.ResetWeightKgs()
		return nil
	case dog.FieldSize:
		m.ResetSize()
		return nil
	case dog.FieldBirthday:
		m.ResetBirthday()
		return nil
	case dog.FieldDogImgID:
		m.ResetDogImgID()
		return nil
	case dog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Dog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.image != nil {
		edges = append(edges, dog.EdgeImage)
	}
	if m.ownerProfiles != nil {
		edges = append(edges, dog.EdgeOwnerProfiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dog.EdgeImage:
		if id := m.image; id != nil {
			return []ent.Value{*id}
		}
	case dog.EdgeOwnerProfiles:
		ids := make([]ent.Value, 0, len(m.ownerProfiles))
		for id := range m.ownerProfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedownerProfiles != nil {
		edges = append(edges, dog.EdgeOwnerProfiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dog.EdgeOwnerProfiles:
		ids := make([]ent.Value, 0, len(m.removedownerProfiles))
		for id := range m.removedownerProfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedimage {
		edges = append(edges, dog.EdgeImage)
	}
	if m.clearedownerProfiles {
		edges = append(edges, dog.EdgeOwnerProfiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DogMutation) EdgeCleared(name string) bool {
	switch name {
	case dog.EdgeImage:
		return m.clearedimage
	case dog.EdgeOwnerProfiles:
		return m.clearedownerProfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DogMutation) ClearEdge(name string) error {
	switch name {
	case dog.EdgeImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown Dog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DogMutation) ResetEdge(name string) error {
	switch name {
	case dog.EdgeImage:
		m.ResetImage()
		return nil
	case dog.EdgeOwnerProfiles:
		m.ResetOwnerProfiles()
		return nil
	}
	return fmt.Errorf("unknown Dog edge %s", name)
}

// DogProfileBreedMutation represents an operation that mutates the DogProfileBreed nodes in the graph.
type DogProfileBreedMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	breed_id      *uuid.UUID
	dog_id        *uuid.UUID
	percentage    *float64
	addpercentage *float64
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DogProfileBreed, error)
	predicates    []predicate.DogProfileBreed
}

var _ ent.Mutation = (*DogProfileBreedMutation)(nil)

// dogprofilebreedOption allows management of the mutation configuration using functional options.
type dogprofilebreedOption func(*DogProfileBreedMutation)

// newDogProfileBreedMutation creates new mutation for the DogProfileBreed entity.
func newDogProfileBreedMutation(c config, op Op, opts ...dogprofilebreedOption) *DogProfileBreedMutation {
	m := &DogProfileBreedMutation{
		config:        c,
		op:            op,
		typ:           TypeDogProfileBreed,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDogProfileBreedID sets the ID field of the mutation.
func withDogProfileBreedID(id uuid.UUID) dogprofilebreedOption {
	return func(m *DogProfileBreedMutation) {
		var (
			err   error
			once  sync.Once
			value *DogProfileBreed
		)
		m.oldValue = func(ctx context.Context) (*DogProfileBreed, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DogProfileBreed.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDogProfileBreed sets the old DogProfileBreed of the mutation.
func withDogProfileBreed(node *DogProfileBreed) dogprofilebreedOption {
	return func(m *DogProfileBreedMutation) {
		m.oldValue = func(context.Context) (*DogProfileBreed, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DogProfileBreedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DogProfileBreedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DogProfileBreed entities.
func (m *DogProfileBreedMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DogProfileBreedMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DogProfileBreedMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DogProfileBreed.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBreedID sets the "breed_id" field.
func (m *DogProfileBreedMutation) SetBreedID(u uuid.UUID) {
	m.breed_id = &u
}

// BreedID returns the value of the "breed_id" field in the mutation.
func (m *DogProfileBreedMutation) BreedID() (r uuid.UUID, exists bool) {
	v := m.breed_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedID returns the old "breed_id" field's value of the DogProfileBreed entity.
// If the DogProfileBreed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogProfileBreedMutation) OldBreedID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBreedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBreedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedID: %w", err)
	}
	return oldValue.BreedID, nil
}

// ResetBreedID resets all changes to the "breed_id" field.
func (m *DogProfileBreedMutation) ResetBreedID() {
	m.breed_id = nil
}

// SetDogID sets the "dog_id" field.
func (m *DogProfileBreedMutation) SetDogID(u uuid.UUID) {
	m.dog_id = &u
}

// DogID returns the value of the "dog_id" field in the mutation.
func (m *DogProfileBreedMutation) DogID() (r uuid.UUID, exists bool) {
	v := m.dog_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDogID returns the old "dog_id" field's value of the DogProfileBreed entity.
// If the DogProfileBreed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogProfileBreedMutation) OldDogID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDogID: %w", err)
	}
	return oldValue.DogID, nil
}

// ResetDogID resets all changes to the "dog_id" field.
func (m *DogProfileBreedMutation) ResetDogID() {
	m.dog_id = nil
}

// SetPercentage sets the "percentage" field.
func (m *DogProfileBreedMutation) SetPercentage(f float64) {
	m.percentage = &f
	m.addpercentage = nil
}

// Percentage returns the value of the "percentage" field in the mutation.
func (m *DogProfileBreedMutation) Percentage() (r float64, exists bool) {
	v := m.percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldPercentage returns the old "percentage" field's value of the DogProfileBreed entity.
// If the DogProfileBreed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogProfileBreedMutation) OldPercentage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPercentage: %w", err)
	}
	return oldValue.Percentage, nil
}

// AddPercentage adds f to the "percentage" field.
func (m *DogProfileBreedMutation) AddPercentage(f float64) {
	if m.addpercentage != nil {
		*m.addpercentage += f
	} else {
		m.addpercentage = &f
	}
}

// AddedPercentage returns the value that was added to the "percentage" field in this mutation.
func (m *DogProfileBreedMutation) AddedPercentage() (r float64, exists bool) {
	v := m.addpercentage
	if v == nil {
		return
	}
	return *v, true
}

// ResetPercentage resets all changes to the "percentage" field.
func (m *DogProfileBreedMutation) ResetPercentage() {
	m.percentage = nil
	m.addpercentage = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DogProfileBreedMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DogProfileBreedMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DogProfileBreed entity.
// If the DogProfileBreed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogProfileBreedMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DogProfileBreedMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DogProfileBreedMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DogProfileBreedMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DogProfileBreed entity.
// If the DogProfileBreed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogProfileBreedMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DogProfileBreedMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the DogProfileBreedMutation builder.
func (m *DogProfileBreedMutation) Where(ps ...predicate.DogProfileBreed) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DogProfileBreedMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DogProfileBreed).
func (m *DogProfileBreedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DogProfileBreedMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.breed_id != nil {
		fields = append(fields, dogprofilebreed.FieldBreedID)
	}
	if m.dog_id != nil {
		fields = append(fields, dogprofilebreed.FieldDogID)
	}
	if m.percentage != nil {
		fields = append(fields, dogprofilebreed.FieldPercentage)
	}
	if m.updated_at != nil {
		fields = append(fields, dogprofilebreed.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, dogprofilebreed.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DogProfileBreedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dogprofilebreed.FieldBreedID:
		return m.BreedID()
	case dogprofilebreed.FieldDogID:
		return m.DogID()
	case dogprofilebreed.FieldPercentage:
		return m.Percentage()
	case dogprofilebreed.FieldUpdatedAt:
		return m.UpdatedAt()
	case dogprofilebreed.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DogProfileBreedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dogprofilebreed.FieldBreedID:
		return m.OldBreedID(ctx)
	case dogprofilebreed.FieldDogID:
		return m.OldDogID(ctx)
	case dogprofilebreed.FieldPercentage:
		return m.OldPercentage(ctx)
	case dogprofilebreed.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dogprofilebreed.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DogProfileBreed field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DogProfileBreedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dogprofilebreed.FieldBreedID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedID(v)
		return nil
	case dogprofilebreed.FieldDogID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDogID(v)
		return nil
	case dogprofilebreed.FieldPercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPercentage(v)
		return nil
	case dogprofilebreed.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dogprofilebreed.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DogProfileBreed field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DogProfileBreedMutation) AddedFields() []string {
	var fields []string
	if m.addpercentage != nil {
		fields = append(fields, dogprofilebreed.FieldPercentage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DogProfileBreedMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dogprofilebreed.FieldPercentage:
		return m.AddedPercentage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DogProfileBreedMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dogprofilebreed.FieldPercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPercentage(v)
		return nil
	}
	return fmt.Errorf("unknown DogProfileBreed numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DogProfileBreedMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DogProfileBreedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DogProfileBreedMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DogProfileBreed nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DogProfileBreedMutation) ResetField(name string) error {
	switch name {
	case dogprofilebreed.FieldBreedID:
		m.ResetBreedID()
		return nil
	case dogprofilebreed.FieldDogID:
		m.ResetDogID()
		return nil
	case dogprofilebreed.FieldPercentage:
		m.ResetPercentage()
		return nil
	case dogprofilebreed.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dogprofilebreed.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown DogProfileBreed field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DogProfileBreedMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DogProfileBreedMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DogProfileBreedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DogProfileBreedMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DogProfileBreedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DogProfileBreedMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DogProfileBreedMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DogProfileBreed unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DogProfileBreedMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DogProfileBreed edge %s", name)
}

// DogProfileOwnerMutation represents an operation that mutates the DogProfileOwner nodes in the graph.
type DogProfileOwnerMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	owner         *uuid.UUID
	clearedowner  bool
	dog           *uuid.UUID
	cleareddog    bool
	done          bool
	oldValue      func(context.Context) (*DogProfileOwner, error)
	predicates    []predicate.DogProfileOwner
}

var _ ent.Mutation = (*DogProfileOwnerMutation)(nil)

// dogprofileownerOption allows management of the mutation configuration using functional options.
type dogprofileownerOption func(*DogProfileOwnerMutation)

// newDogProfileOwnerMutation creates new mutation for the DogProfileOwner entity.
func newDogProfileOwnerMutation(c config, op Op, opts ...dogprofileownerOption) *DogProfileOwnerMutation {
	m := &DogProfileOwnerMutation{
		config:        c,
		op:            op,
		typ:           TypeDogProfileOwner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDogProfileOwnerID sets the ID field of the mutation.
func withDogProfileOwnerID(id uuid.UUID) dogprofileownerOption {
	return func(m *DogProfileOwnerMutation) {
		var (
			err   error
			once  sync.Once
			value *DogProfileOwner
		)
		m.oldValue = func(ctx context.Context) (*DogProfileOwner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DogProfileOwner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDogProfileOwner sets the old DogProfileOwner of the mutation.
func withDogProfileOwner(node *DogProfileOwner) dogprofileownerOption {
	return func(m *DogProfileOwnerMutation) {
		m.oldValue = func(context.Context) (*DogProfileOwner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DogProfileOwnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DogProfileOwnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DogProfileOwner entities.
func (m *DogProfileOwnerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DogProfileOwnerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DogProfileOwnerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DogProfileOwner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOwnerID sets the "owner_id" field.
func (m *DogProfileOwnerMutation) SetOwnerID(u uuid.UUID) {
	m.owner = &u
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *DogProfileOwnerMutation) OwnerID() (r uuid.UUID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the DogProfileOwner entity.
// If the DogProfileOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogProfileOwnerMutation) OldOwnerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *DogProfileOwnerMutation) ResetOwnerID() {
	m.owner = nil
}

// SetDogID sets the "dog_id" field.
func (m *DogProfileOwnerMutation) SetDogID(u uuid.UUID) {
	m.dog = &u
}

// DogID returns the value of the "dog_id" field in the mutation.
func (m *DogProfileOwnerMutation) DogID() (r uuid.UUID, exists bool) {
	v := m.dog
	if v == nil {
		return
	}
	return *v, true
}

// OldDogID returns the old "dog_id" field's value of the DogProfileOwner entity.
// If the DogProfileOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogProfileOwnerMutation) OldDogID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDogID: %w", err)
	}
	return oldValue.DogID, nil
}

// ResetDogID resets all changes to the "dog_id" field.
func (m *DogProfileOwnerMutation) ResetDogID() {
	m.dog = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DogProfileOwnerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DogProfileOwnerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DogProfileOwner entity.
// If the DogProfileOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogProfileOwnerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DogProfileOwnerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DogProfileOwnerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DogProfileOwnerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DogProfileOwner entity.
// If the DogProfileOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DogProfileOwnerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DogProfileOwnerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *DogProfileOwnerMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *DogProfileOwnerMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *DogProfileOwnerMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *DogProfileOwnerMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// ClearDog clears the "dog" edge to the Dog entity.
func (m *DogProfileOwnerMutation) ClearDog() {
	m.cleareddog = true
}

// DogCleared reports if the "dog" edge to the Dog entity was cleared.
func (m *DogProfileOwnerMutation) DogCleared() bool {
	return m.cleareddog
}

// DogIDs returns the "dog" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DogID instead. It exists only for internal usage by the builders.
func (m *DogProfileOwnerMutation) DogIDs() (ids []uuid.UUID) {
	if id := m.dog; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDog resets all changes to the "dog" edge.
func (m *DogProfileOwnerMutation) ResetDog() {
	m.dog = nil
	m.cleareddog = false
}

// Where appends a list predicates to the DogProfileOwnerMutation builder.
func (m *DogProfileOwnerMutation) Where(ps ...predicate.DogProfileOwner) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DogProfileOwnerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DogProfileOwner).
func (m *DogProfileOwnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DogProfileOwnerMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.owner != nil {
		fields = append(fields, dogprofileowner.FieldOwnerID)
	}
	if m.dog != nil {
		fields = append(fields, dogprofileowner.FieldDogID)
	}
	if m.updated_at != nil {
		fields = append(fields, dogprofileowner.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, dogprofileowner.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DogProfileOwnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dogprofileowner.FieldOwnerID:
		return m.OwnerID()
	case dogprofileowner.FieldDogID:
		return m.DogID()
	case dogprofileowner.FieldUpdatedAt:
		return m.UpdatedAt()
	case dogprofileowner.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DogProfileOwnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dogprofileowner.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case dogprofileowner.FieldDogID:
		return m.OldDogID(ctx)
	case dogprofileowner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dogprofileowner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DogProfileOwner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DogProfileOwnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dogprofileowner.FieldOwnerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case dogprofileowner.FieldDogID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDogID(v)
		return nil
	case dogprofileowner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dogprofileowner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DogProfileOwner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DogProfileOwnerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DogProfileOwnerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DogProfileOwnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DogProfileOwner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DogProfileOwnerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DogProfileOwnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DogProfileOwnerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DogProfileOwner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DogProfileOwnerMutation) ResetField(name string) error {
	switch name {
	case dogprofileowner.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case dogprofileowner.FieldDogID:
		m.ResetDogID()
		return nil
	case dogprofileowner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dogprofileowner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown DogProfileOwner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DogProfileOwnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, dogprofileowner.EdgeOwner)
	}
	if m.dog != nil {
		edges = append(edges, dogprofileowner.EdgeDog)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DogProfileOwnerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dogprofileowner.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case dogprofileowner.EdgeDog:
		if id := m.dog; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DogProfileOwnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DogProfileOwnerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DogProfileOwnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, dogprofileowner.EdgeOwner)
	}
	if m.cleareddog {
		edges = append(edges, dogprofileowner.EdgeDog)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DogProfileOwnerMutation) EdgeCleared(name string) bool {
	switch name {
	case dogprofileowner.EdgeOwner:
		return m.clearedowner
	case dogprofileowner.EdgeDog:
		return m.cleareddog
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DogProfileOwnerMutation) ClearEdge(name string) error {
	switch name {
	case dogprofileowner.EdgeOwner:
		m.ClearOwner()
		return nil
	case dogprofileowner.EdgeDog:
		m.ClearDog()
		return nil
	}
	return fmt.Errorf("unknown DogProfileOwner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DogProfileOwnerMutation) ResetEdge(name string) error {
	switch name {
	case dogprofileowner.EdgeOwner:
		m.ResetOwner()
		return nil
	case dogprofileowner.EdgeDog:
		m.ResetDog()
		return nil
	}
	return fmt.Errorf("unknown DogProfileOwner edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	url           *string
	width         *int
	addwidth      *int
	height        *int
	addheight     *int
	_type         *string
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	users         map[uuid.UUID]struct{}
	removedusers  map[uuid.UUID]struct{}
	clearedusers  bool
	dogs          map[uuid.UUID]struct{}
	removeddogs   map[uuid.UUID]struct{}
	cleareddogs   bool
	done          bool
	oldValue      func(context.Context) (*Image, error)
	predicates    []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id uuid.UUID) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Image entities.
func (m *ImageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Image.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "url" field.
func (m *ImageMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ImageMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *ImageMutation) ResetURL() {
	m.url = nil
}

// SetWidth sets the "width" field.
func (m *ImageMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *ImageMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *ImageMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *ImageMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *ImageMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *ImageMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *ImageMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *ImageMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *ImageMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *ImageMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetType sets the "type" field.
func (m *ImageMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ImageMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ImageMutation) ResetType() {
	m._type = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *ImageMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *ImageMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *ImageMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *ImageMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *ImageMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *ImageMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *ImageMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddDogIDs adds the "dogs" edge to the Dog entity by ids.
func (m *ImageMutation) AddDogIDs(ids ...uuid.UUID) {
	if m.dogs == nil {
		m.dogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.dogs[ids[i]] = struct{}{}
	}
}

// ClearDogs clears the "dogs" edge to the Dog entity.
func (m *ImageMutation) ClearDogs() {
	m.cleareddogs = true
}

// DogsCleared reports if the "dogs" edge to the Dog entity was cleared.
func (m *ImageMutation) DogsCleared() bool {
	return m.cleareddogs
}

// RemoveDogIDs removes the "dogs" edge to the Dog entity by IDs.
func (m *ImageMutation) RemoveDogIDs(ids ...uuid.UUID) {
	if m.removeddogs == nil {
		m.removeddogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.dogs, ids[i])
		m.removeddogs[ids[i]] = struct{}{}
	}
}

// RemovedDogs returns the removed IDs of the "dogs" edge to the Dog entity.
func (m *ImageMutation) RemovedDogsIDs() (ids []uuid.UUID) {
	for id := range m.removeddogs {
		ids = append(ids, id)
	}
	return
}

// DogsIDs returns the "dogs" edge IDs in the mutation.
func (m *ImageMutation) DogsIDs() (ids []uuid.UUID) {
	for id := range m.dogs {
		ids = append(ids, id)
	}
	return
}

// ResetDogs resets all changes to the "dogs" edge.
func (m *ImageMutation) ResetDogs() {
	m.dogs = nil
	m.cleareddogs = false
	m.removeddogs = nil
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.url != nil {
		fields = append(fields, image.FieldURL)
	}
	if m.width != nil {
		fields = append(fields, image.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, image.FieldHeight)
	}
	if m._type != nil {
		fields = append(fields, image.FieldType)
	}
	if m.updated_at != nil {
		fields = append(fields, image.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, image.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldURL:
		return m.URL()
	case image.FieldWidth:
		return m.Width()
	case image.FieldHeight:
		return m.Height()
	case image.FieldType:
		return m.GetType()
	case image.FieldUpdatedAt:
		return m.UpdatedAt()
	case image.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldURL:
		return m.OldURL(ctx)
	case image.FieldWidth:
		return m.OldWidth(ctx)
	case image.FieldHeight:
		return m.OldHeight(ctx)
	case image.FieldType:
		return m.OldType(ctx)
	case image.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case image.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case image.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case image.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case image.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case image.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case image.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	var fields []string
	if m.addwidth != nil {
		fields = append(fields, image.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, image.FieldHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case image.FieldWidth:
		return m.AddedWidth()
	case image.FieldHeight:
		return m.AddedHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case image.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case image.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldURL:
		m.ResetURL()
		return nil
	case image.FieldWidth:
		m.ResetWidth()
		return nil
	case image.FieldHeight:
		m.ResetHeight()
		return nil
	case image.FieldType:
		m.ResetType()
		return nil
	case image.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case image.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, image.EdgeUsers)
	}
	if m.dogs != nil {
		edges = append(edges, image.EdgeDogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case image.EdgeDogs:
		ids := make([]ent.Value, 0, len(m.dogs))
		for id := range m.dogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, image.EdgeUsers)
	}
	if m.removeddogs != nil {
		edges = append(edges, image.EdgeDogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case image.EdgeDogs:
		ids := make([]ent.Value, 0, len(m.removeddogs))
		for id := range m.removeddogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, image.EdgeUsers)
	}
	if m.cleareddogs {
		edges = append(edges, image.EdgeDogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	switch name {
	case image.EdgeUsers:
		return m.clearedusers
	case image.EdgeDogs:
		return m.cleareddogs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	switch name {
	case image.EdgeUsers:
		m.ResetUsers()
		return nil
	case image.EdgeDogs:
		m.ResetDogs()
		return nil
	}
	return fmt.Errorf("unknown Image edge %s", name)
}

// ProfileMutation represents an operation that mutates the Profile nodes in the graph.
type ProfileMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	description   *string
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	users         map[uuid.UUID]struct{}
	removedusers  map[uuid.UUID]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Profile, error)
	predicates    []predicate.Profile
}

var _ ent.Mutation = (*ProfileMutation)(nil)

// profileOption allows management of the mutation configuration using functional options.
type profileOption func(*ProfileMutation)

// newProfileMutation creates new mutation for the Profile entity.
func newProfileMutation(c config, op Op, opts ...profileOption) *ProfileMutation {
	m := &ProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileID sets the ID field of the mutation.
func withProfileID(id uuid.UUID) profileOption {
	return func(m *ProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *Profile
		)
		m.oldValue = func(ctx context.Context) (*Profile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfile sets the old Profile of the mutation.
func withProfile(node *Profile) profileOption {
	return func(m *ProfileMutation) {
		m.oldValue = func(context.Context) (*Profile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Profile entities.
func (m *ProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Profile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProfileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProfileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProfileMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProfileMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProfileMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProfileMutation) ResetDescription() {
	m.description = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *ProfileMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *ProfileMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *ProfileMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *ProfileMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *ProfileMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *ProfileMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *ProfileMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the ProfileMutation builder.
func (m *ProfileMutation) Where(ps ...predicate.Profile) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProfileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Profile).
func (m *ProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, profile.FieldName)
	}
	if m.description != nil {
		fields = append(fields, profile.FieldDescription)
	}
	if m.updated_at != nil {
		fields = append(fields, profile.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, profile.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldName:
		return m.Name()
	case profile.FieldDescription:
		return m.Description()
	case profile.FieldUpdatedAt:
		return m.UpdatedAt()
	case profile.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profile.FieldName:
		return m.OldName(ctx)
	case profile.FieldDescription:
		return m.OldDescription(ctx)
	case profile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Profile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case profile.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case profile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Profile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Profile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileMutation) ResetField(name string) error {
	switch name {
	case profile.FieldName:
		m.ResetName()
		return nil
	case profile.FieldDescription:
		m.ResetDescription()
		return nil
	case profile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, profile.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, profile.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, profile.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case profile.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Profile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileMutation) ResetEdge(name string) error {
	switch name {
	case profile.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Profile edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	first_name         *string
	last_name          *string
	updated_at         *time.Time
	created_at         *time.Time
	clearedFields      map[string]struct{}
	profile            *uuid.UUID
	clearedprofile     bool
	image              *uuid.UUID
	clearedimage       bool
	dogProfiles        map[uuid.UUID]struct{}
	removeddogProfiles map[uuid.UUID]struct{}
	cleareddogProfiles bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetUserImageID sets the "user_image_id" field.
func (m *UserMutation) SetUserImageID(u uuid.UUID) {
	m.image = &u
}

// UserImageID returns the value of the "user_image_id" field in the mutation.
func (m *UserMutation) UserImageID() (r uuid.UUID, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldUserImageID returns the old "user_image_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserImageID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserImageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserImageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserImageID: %w", err)
	}
	return oldValue.UserImageID, nil
}

// ResetUserImageID resets all changes to the "user_image_id" field.
func (m *UserMutation) ResetUserImageID() {
	m.image = nil
}

// SetProfileID sets the "profile_id" field.
func (m *UserMutation) SetProfileID(u uuid.UUID) {
	m.profile = &u
}

// ProfileID returns the value of the "profile_id" field in the mutation.
func (m *UserMutation) ProfileID() (r uuid.UUID, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileID returns the old "profile_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfileID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileID: %w", err)
	}
	return oldValue.ProfileID, nil
}

// ResetProfileID resets all changes to the "profile_id" field.
func (m *UserMutation) ResetProfileID() {
	m.profile = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *UserMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *UserMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ProfileIDs() (ids []uuid.UUID) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// SetImageID sets the "image" edge to the Image entity by id.
func (m *UserMutation) SetImageID(id uuid.UUID) {
	m.image = &id
}

// ClearImage clears the "image" edge to the Image entity.
func (m *UserMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *UserMutation) ImageCleared() bool {
	return m.clearedimage
}

// ImageID returns the "image" edge ID in the mutation.
func (m *UserMutation) ImageID() (id uuid.UUID, exists bool) {
	if m.image != nil {
		return *m.image, true
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImageID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ImageIDs() (ids []uuid.UUID) {
	if id := m.image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *UserMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
}

// AddDogProfileIDs adds the "dogProfiles" edge to the DogProfileOwner entity by ids.
func (m *UserMutation) AddDogProfileIDs(ids ...uuid.UUID) {
	if m.dogProfiles == nil {
		m.dogProfiles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.dogProfiles[ids[i]] = struct{}{}
	}
}

// ClearDogProfiles clears the "dogProfiles" edge to the DogProfileOwner entity.
func (m *UserMutation) ClearDogProfiles() {
	m.cleareddogProfiles = true
}

// DogProfilesCleared reports if the "dogProfiles" edge to the DogProfileOwner entity was cleared.
func (m *UserMutation) DogProfilesCleared() bool {
	return m.cleareddogProfiles
}

// RemoveDogProfileIDs removes the "dogProfiles" edge to the DogProfileOwner entity by IDs.
func (m *UserMutation) RemoveDogProfileIDs(ids ...uuid.UUID) {
	if m.removeddogProfiles == nil {
		m.removeddogProfiles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.dogProfiles, ids[i])
		m.removeddogProfiles[ids[i]] = struct{}{}
	}
}

// RemovedDogProfiles returns the removed IDs of the "dogProfiles" edge to the DogProfileOwner entity.
func (m *UserMutation) RemovedDogProfilesIDs() (ids []uuid.UUID) {
	for id := range m.removeddogProfiles {
		ids = append(ids, id)
	}
	return
}

// DogProfilesIDs returns the "dogProfiles" edge IDs in the mutation.
func (m *UserMutation) DogProfilesIDs() (ids []uuid.UUID) {
	for id := range m.dogProfiles {
		ids = append(ids, id)
	}
	return
}

// ResetDogProfiles resets all changes to the "dogProfiles" edge.
func (m *UserMutation) ResetDogProfiles() {
	m.dogProfiles = nil
	m.cleareddogProfiles = false
	m.removeddogProfiles = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.image != nil {
		fields = append(fields, user.FieldUserImageID)
	}
	if m.profile != nil {
		fields = append(fields, user.FieldProfileID)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldUserImageID:
		return m.UserImageID()
	case user.FieldProfileID:
		return m.ProfileID()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldUserImageID:
		return m.OldUserImageID(ctx)
	case user.FieldProfileID:
		return m.OldProfileID(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldUserImageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserImageID(v)
		return nil
	case user.FieldProfileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileID(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldUserImageID:
		m.ResetUserImageID()
		return nil
	case user.FieldProfileID:
		m.ResetProfileID()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.profile != nil {
		edges = append(edges, user.EdgeProfile)
	}
	if m.image != nil {
		edges = append(edges, user.EdgeImage)
	}
	if m.dogProfiles != nil {
		edges = append(edges, user.EdgeDogProfiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeImage:
		if id := m.image; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeDogProfiles:
		ids := make([]ent.Value, 0, len(m.dogProfiles))
		for id := range m.dogProfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddogProfiles != nil {
		edges = append(edges, user.EdgeDogProfiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDogProfiles:
		ids := make([]ent.Value, 0, len(m.removeddogProfiles))
		for id := range m.removeddogProfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprofile {
		edges = append(edges, user.EdgeProfile)
	}
	if m.clearedimage {
		edges = append(edges, user.EdgeImage)
	}
	if m.cleareddogProfiles {
		edges = append(edges, user.EdgeDogProfiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeProfile:
		return m.clearedprofile
	case user.EdgeImage:
		return m.clearedimage
	case user.EdgeDogProfiles:
		return m.cleareddogProfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeProfile:
		m.ClearProfile()
		return nil
	case user.EdgeImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeProfile:
		m.ResetProfile()
		return nil
	case user.EdgeImage:
		m.ResetImage()
		return nil
	case user.EdgeDogProfiles:
		m.ResetDogProfiles()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
